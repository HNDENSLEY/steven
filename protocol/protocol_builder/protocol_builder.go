package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

const (
	idSearchString = "Currently the packet id is: 0x"
)

var (
	protocol, dir string
	packets       []packetIDPair
)

type packetIDPair struct {
	id     int
	packet string
}

func main() {
	if len(os.Args) != 4 {
		log.Println("Missing target, protocol or dir")
		os.Exit(4)
	}

	input := os.Args[1]
	protocol = os.Args[2]
	dir = os.Args[3]

	fs := token.NewFileSet()
	parsedFile, err := parser.ParseFile(fs, input, nil, parser.ParseComments)
	if err != nil {
		log.Fatalln(err)
	}

	var buf bytes.Buffer

	buf.WriteString(`
		// GENERATED BY PROTOCOL_BUILDER
		// DO NOT TOUCH

    `)
	fmt.Fprintf(&buf, "package %s\n", parsedFile.Name)
	buf.WriteString(`
		import ( 
			"bytes"
			"io"
		)
	`)

	for _, decl := range parsedFile.Decls {
		switch decl := decl.(type) {
		case *ast.GenDecl:
			if decl.Tok != token.TYPE {
				continue
			}

			if decl.Doc == nil {
				continue
			}
			doc := decl.Doc.Text()
			pos := strings.Index(doc, idSearchString)
			if pos == -1 {
				continue
			}

			if len(decl.Specs) != 1 {
				return
			}
			handleType(&buf, decl.Specs[0], strings.TrimSpace(doc[pos+len(idSearchString):]))
		}
	}

	buf.WriteString("func init() {\n")
	for _, pair := range packets {
		fmt.Fprintf(&buf, "packetCreator[%s][%s][%d] = func () Packet { return &%s{} }\n", protocol, dir, pair.id, pair.packet)
	}
	buf.WriteString("}\n")

	b, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("format error: %s", err)
	}

	o, err := os.Create(input[:len(input)-len(filepath.Ext(input))] + "_proto.go")
	if err != nil {
		log.Fatalln(err)
	}
	defer o.Close()
	o.Write(b)
}

func handleType(w *bytes.Buffer, spec ast.Spec, info string) {
	switch spec := spec.(type) {
	case *ast.TypeSpec:
		s, ok := spec.Type.(*ast.StructType)
		if !ok {
			log.Fatalln("Invalid type for protocol builder")
		}

		id, err := strconv.ParseInt(info, 16, 32)
		if err != nil {
			log.Fatalln(err)
		}

		packets = append(packets, packetIDPair{int(id), spec.Name.Name})

		short := string(strings.ToLower(spec.Name.String())[0])

		fmt.Fprintf(w, "func (%s *%s) id() int { return %d }\n", short, spec.Name, id)

		fmt.Fprintf(w, "func (%s *%s) write(w *bytes.Buffer) error { \n", short, spec.Name)
		if s.Fields.NumFields() > 0 {
			w.WriteString("var err error\n")

			scratchSize := 0
			for _, field := range s.Fields.List {
				if i := checkScratch(field); i > scratchSize {
					scratchSize = i
				}
			}
			if scratchSize > 0 {
				fmt.Fprintf(w, "var tmp [%d]byte\n", scratchSize)
			}

			for _, field := range s.Fields.List {
				for _, name := range field.Names {
					writer(w, field.Type, fmt.Sprintf("%s.%s", short, name), field.Tag)
				}
			}
		}
		w.WriteString("return nil\n")
		w.WriteString("}\n")

		fmt.Fprintf(w, "func (%s *%s) read(r *bytes.Reader) error { \n", short, spec.Name)
		if s.Fields.NumFields() > 0 {
			w.WriteString("var err error\n")

			scratchSize := 0
			for _, field := range s.Fields.List {
				if i := checkScratch(field); i > scratchSize {
					scratchSize = i
				}
			}
			if scratchSize > 0 {
				fmt.Fprintf(w, "var tmp [%d]byte\n", scratchSize)
			}

			for _, field := range s.Fields.List {
				ti, ok := field.Type.(*ast.Ident)
				if ok {
					for _, name := range field.Names {
						generateRead(w, ti, fmt.Sprintf("%s.%s", short, name))
					}
				}
			}
		}
		w.WriteString("return nil\n")
		w.WriteString("}\n")
		w.WriteString("\n\n")
	default:
		log.Printf("Unhandled: %#v\n", spec)
	}
}

var writerTmpCount = 0

func writer(w *bytes.Buffer, t ast.Expr, name string, tag *ast.BasicLit) {
	switch t := t.(type) {
	case *ast.Ident:
		generateWrite(w, t, name)
	case *ast.ArrayType:
		if tag == nil {
			panic("missing tag")
		}
		tv := tag.Value[1 : len(tag.Value)-1]
		writerTmpCount++
		tmpName := fmt.Sprintf("tmp%d", writerTmpCount)
		fmt.Fprintf(w, "%s := %s(len(%s))\n", tmpName, tv, name)
		writer(w, &ast.Ident{Name: tv}, tmpName, nil)

		if et, ok := t.Elt.(*ast.Ident); ok && (et.Name == "byte" || et.Name == "uint8") {
			fmt.Fprintf(w, "if _, err = w.Write(%s); err != nil { return err }\n", name)
		} else {
			fmt.Fprintf(w, "for i%[1]d := %[3]s(0); i%[1]d < %[2]s; i%[1]d++ {\n", writerTmpCount, tmpName, tv)
			writer(w, t.Elt, fmt.Sprintf("%s[i%d]", name, writerTmpCount), nil)
			w.WriteString("}\n")
		}
	default:
		log.Printf("Unhandled %#v\n", t)
	}
}

func generateWrite(w *bytes.Buffer, typeIdent *ast.Ident, name string) {
	funcName := ""
	switch typeIdent.Name {
	case "VarInt":
		funcName = "writeVarInt"
	case "string":
		funcName = "writeString"
	case "bool":
		funcName = "writeBool"
	case "int8", "uint8", "byte":
		generateNumberWrite(w, name, typeIdent.Name, 1, typeIdent.Name[0] != 'i')
	case "int16", "uint16":
		generateNumberWrite(w, name, typeIdent.Name, 2, typeIdent.Name[0] == 'u')
	case "int32", "uint32":
		generateNumberWrite(w, name, typeIdent.Name, 4, typeIdent.Name[0] == 'u')
	case "int64", "uint64":
		generateNumberWrite(w, name, typeIdent.Name, 8, typeIdent.Name[0] == 'u')
	default:
		fmt.Printf("Unsupported type: %s\n", typeIdent.Name)
		return
	}
	if len(funcName) != 0 {
		fmt.Fprintf(w, "if err = %s(w, %s); err != nil { return err }\n", funcName, name)
	}
}

func generateRead(w *bytes.Buffer, typeIdent *ast.Ident, name string) {
	funcName := ""
	switch typeIdent.Name {
	case "VarInt":
		funcName = "readVarInt"
	case "string":
		funcName = "readString"
	case "bool":
		funcName = "readBool"
	case "int8", "uint8", "byte":
		generateNumberRead(w, name, typeIdent.Name, 1, typeIdent.Name[0] == 'u' || typeIdent.Name == "byte")
	case "int16", "uint16":
		generateNumberRead(w, name, typeIdent.Name, 2, typeIdent.Name[0] == 'u')
	case "int32", "uint32":
		generateNumberRead(w, name, typeIdent.Name, 4, typeIdent.Name[0] == 'u')
	case "int64", "uint64":
		generateNumberRead(w, name, typeIdent.Name, 8, typeIdent.Name[0] == 'u')
	default:
		fmt.Printf("Unsupported type: %s\n", typeIdent.Name)
		return
	}
	if len(funcName) != 0 {
		fmt.Fprintf(w, "if %s, err = %s(r); err != nil { return err }\n", name, funcName)
	}
}

func generateNumberRead(w *bytes.Buffer, name, t string, size int, unsigned bool) {
	origT := t
	if !unsigned {
		t = "u" + t
	}
	fmt.Fprintf(w, "if _, err = io.ReadFull(r, tmp[:%d]); err != nil { return err }\n", size)
	fmt.Fprintf(w, "%s = ", name)
	if !unsigned {
		fmt.Fprintf(w, "%s(", origT)
	}
	for i := 0; i < size; i++ {
		fmt.Fprintf(w, "(%s(tmp[%d]) << %d)", t, size-1-i, i*8)
		if i != size-1 {
			w.WriteString("|")
		}
	}
	if !unsigned {
		w.WriteString(")")
	}
	w.WriteString("\n")
}

func generateNumberWrite(w *bytes.Buffer, name string, t string, size int, unsigned bool) {
	for i := 0; i < size; i++ {
		fmt.Fprintf(w, "tmp[%d] =  byte(%s >> %d)\n", i, name, (size-1-i)*8)
	}
	fmt.Fprintf(w, "if _, err = w.Write(tmp[:%d]); err != nil { return err }\n", size)
}

func checkScratch(field *ast.Field) int {
	typeIdent, ok := field.Type.(*ast.Ident)
	if !ok {
		if a, ok := field.Type.(*ast.ArrayType); ok {
			return checkScratchName(a.Elt.(*ast.Ident).Name)
		}
		return 0
	}
	return checkScratchName(typeIdent.Name)
}

func checkScratchName(name string) int {
	switch name {
	case "int8", "uint8", "byte":
		return 1
	case "int16", "uint16":
		return 2
	case "int32", "uint32":
		return 4
	case "int64", "uint64":
		return 8
	default:
		return 0
	}
}
