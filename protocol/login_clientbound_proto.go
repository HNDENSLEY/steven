// GENERATED BY PROTOCOL_BUILDER
// DO NOT TOUCH

package protocol

import (
	"bytes"
	"io"
)

func (l *LoginDisconnect) id() int { return 0 }
func (l *LoginDisconnect) write(w *bytes.Buffer) error {
	var err error
	if err = writeString(w, l.Reason); err != nil {
		return err
	}
	return nil
}
func (l *LoginDisconnect) read(r *bytes.Reader) error {
	var err error
	if l.Reason, err = readString(r); err != nil {
		return err
	}
	return nil
}

func (e *EncryptionRequest) id() int { return 1 }
func (e *EncryptionRequest) write(w *bytes.Buffer) error {
	var err error
	var tmp [4]byte
	if err = writeString(w, e.ServerID); err != nil {
		return err
	}
	tmp1 := VarInt(len(e.PublicKey))
	if err = writeVarInt(w, tmp1); err != nil {
		return err
	}
	if _, err = w.Write(e.PublicKey); err != nil {
		return err
	}
	tmp2 := VarInt(len(e.VerifyToken))
	if err = writeVarInt(w, tmp2); err != nil {
		return err
	}
	if _, err = w.Write(e.VerifyToken); err != nil {
		return err
	}
	tmp3 := byte(len(e.Test))
	tmp[0] = byte(tmp3 >> 0)
	if _, err = w.Write(tmp[:1]); err != nil {
		return err
	}
	for i3 := byte(0); i3 < tmp3; i3++ {
		tmp[0] = byte(e.Test[i3] >> 24)
		tmp[1] = byte(e.Test[i3] >> 16)
		tmp[2] = byte(e.Test[i3] >> 8)
		tmp[3] = byte(e.Test[i3] >> 0)
		if _, err = w.Write(tmp[:4]); err != nil {
			return err
		}
	}
	return nil
}
func (e *EncryptionRequest) read(r *bytes.Reader) error {
	var err error
	var tmp [4]byte
	if e.ServerID, err = readString(r); err != nil {
		return err
	}
	return nil
}

func init() {
	packetCreator[Login][clientbound][0] = func() Packet { return &LoginDisconnect{} }
	packetCreator[Login][clientbound][1] = func() Packet { return &EncryptionRequest{} }
}
